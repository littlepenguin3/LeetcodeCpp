# leetcode352.将数据流变为多个不相交区间

### 完成情况
Data: Oct 9th,2021 Saturday
剩余时间：with solution 20:56:7 +5:00:0 
通过测试用例：AC
提交错误次数：0

### 个人解题思路
超时未解出

### 题解解题思路
构造一个映射map\[start\] = end 表示闭区间\[start,end\]
由于map是一个红黑树，其内部元素的key是不重复而且有序的，故map相当于排序好的不相交区间
当一个新的元素d要被插入时，考虑以下五种情况  
情况一：存在一个区间[l, r]包含d,即d>=l&&&d<=r,此时不需要任何操作  
情况二：存在一个区间[l, r]，其中l=d+1，则该区间变为[d, r]   
情况三：如果存在一个区间[l, r],其中r=d-1，则该区间变为[l, d]  
情况四：如果情况二和情况三同时满足，两区间要合并为一个新区间[l1, d2]   
情况五：在上述四种情况均不满足的情况下，单独形成一个新的区间[d, d] 
map的key是无重复的单调递增序列，支持upper_bound和lower_bound以及binary_search操作，因此
当要插入d时，`iterator it = map.upper_bound(d)`表示l比d大的第一个区间，故l小于等于d的第一个区间一定是prev(it) **注意！关联容器map不能用it-1,也不可以迭代器做差**
然后根据上述五种情况进行比较然后插入即可，注意左区间改变时要先把原有区间删除后重新添加，因为不能直接改变map的key  

### 复杂度分析
时间复杂度：一次添加合并区间O(logn) RBT的功劳  
空间复杂度：最坏情况n个独立区间O(n)

### 其他
代码中upper_bound与lower_bound效果完全一样，但是本质上upper_bound才是对的，lower_bound对是因为一个巧合，map不能添加重复的key，导致添加\[val,val\]时由于查重没有添加进去

